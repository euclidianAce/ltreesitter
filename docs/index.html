<html><style>
html {
   background-color: #16191a;
}

body {
   background-color: #181a1b;
   margin: auto;
   max-width: 70em;
   width: 90%;
   padding: 32px;
   font-family: Helvetica, Arial, sans-serif;
   color: #e8e6e3;
}

a {
   text-decoration: none;
   color: #3391ff;
}

h2 {
   color: #117dee;
}

</style><body><table width="100%"><tbody><tr><td valign=top><h4>ltreesitter</h4><p><a href="#_get_registry_entry">_get_registry_entry</a><br><a href="#load">load</a><br><a href="#require">require</a><br></p><h4>Cursor</h4><p><a href="#Cursor.current_field_name">Cursor.current_field_name</a><br><a href="#Cursor.current_node">Cursor.current_node</a><br><a href="#Cursor.goto_first_child">Cursor.goto_first_child</a><br><a href="#Cursor.goto_next_sibling">Cursor.goto_next_sibling</a><br><a href="#Cursor.goto_parent">Cursor.goto_parent</a><br><a href="#Cursor.reset">Cursor.reset</a><br></p><h4>Node</h4><p><a href="#Node.child">Node.child</a><br><a href="#Node.child_by_field_name">Node.child_by_field_name</a><br><a href="#Node.child_count">Node.child_count</a><br><a href="#Node.children">Node.children</a><br><a href="#Node.create_cursor">Node.create_cursor</a><br><a href="#Node.end_byte">Node.end_byte</a><br><a href="#Node.end_point">Node.end_point</a><br><a href="#Node.is_extra">Node.is_extra</a><br><a href="#Node.is_missing">Node.is_missing</a><br><a href="#Node.is_named">Node.is_named</a><br><a href="#Node.name">Node.name</a><br><a href="#Node.named_child">Node.named_child</a><br><a href="#Node.named_child_count">Node.named_child_count</a><br><a href="#Node.named_children">Node.named_children</a><br><a href="#Node.next_named_sibling">Node.next_named_sibling</a><br><a href="#Node.next_sibling">Node.next_sibling</a><br><a href="#Node.prev_named_sibling">Node.prev_named_sibling</a><br><a href="#Node.prev_sibling">Node.prev_sibling</a><br><a href="#Node.source">Node.source</a><br><a href="#Node.start_byte">Node.start_byte</a><br><a href="#Node.start_point">Node.start_point</a><br><a href="#Node.type">Node.type</a><br></p></td><td valign=top><h4>Parser</h4><p><a href="#Parser.parse_string">Parser.parse_string</a><br><a href="#Parser.query">Parser.query</a><br><a href="#Parser.set_timeout">Parser.set_timeout</a><br></p><h4>Query</h4><p><a href="#Query.capture">Query.capture</a><br><a href="#Query.exec">Query.exec</a><br><a href="#Query.match">Query.match</a><br><a href="#Query.with">Query.with</a><br></p><h4>Tree</h4><p><a href="#Tree.copy">Tree.copy</a><br><a href="#Tree.edit">Tree.edit</a><br><a href="#Tree.root">Tree.root</a><br></p></td></tr></tbody></table><br><br><br><br><br><br><br><br><br><br><h2><a id="_get_registry_entry"><code>_get_registry_entry: function(): table </code></a></h2><p>ltreesitter uses a table in the Lua registry to keep references alive and prevent Lua's garbage collection from collecting things that the library needs internally.<br>   The behavior nor existence of this function should not be relied upon and is included strictly for memory debugging purposes<br><br>   Though, if you are looking to debug a segfault/garbage collection bug, this is a useful tool in addition to the lua inspect module</p><br><h2><a id="load"><code>load: function(file_name: string, language_name: string): Parser, string </code></a></h2><p>Load a parser from a given file<br><br>   On unix this uses dlopen, so if a path without a path separator is given, dlopen has its own path's that it will search for your file in.<br>   So if in doubt use a file path like<br>   <pre><br>   local my_parser = ltreesitter.load("./my_parser.so", "my_language")<br>   </pre><br><br>   * Currently this does not work on Windows<br>   (The entire library doesn't work on Windows since this is one of the entry points to any of the functionality)</p><br><h2><a id="require"><code>require: function(library_file_name: string, language_name: string): Parser </code></a></h2><p>Search <code>package.cpath</code> for a parser with the filename <code>library_file_name.so</code> (or <code>.dll</code> on Windows) and try to load the symbol <code>tree_sitter_'language_name'</code><br>   <code>language_name</code> is optional and will be set to <code>library_file_name</code> if not provided.<br><br>   So if you want to load a Lua parser from a file named <code>lua.so</code> then use <code>ltreesitter.require("lua")</code><br>   But if you want to load a Lua parser from a file named <code>parser.so</code> then use <code>ltreesitter.require("parser", "lua")</code><br><br>   Like the regular <code>require</code>, this will error if the parser is not found or the symbol couldn't be loaded. Use either <code>pcall</code> or <code>ltreesitter.load</code> to not error out on failure.<br><br>   <pre><br>   local my_parser = ltreesitter.require("my_language")<br>   my_parser:parse_string(...)<br>   -- etc.<br>   </pre><br><br>   * Currently this does not work on Windows<br>   (The entire library doesn't work on Windows since this is one of the entry points to any of the functionality)</p><br><br><h2><a id="Cursor.current_field_name"><code>Cursor.current_field_name: function(Cursor): string </code></a></h2><p>Get the field name of the current node under the cursor</p><br><h2><a id="Cursor.current_node"><code>Cursor.current_node: function(Cursor): Node </code></a></h2><p>Get the current node under the cursor</p><br><h2><a id="Cursor.goto_first_child"><code>Cursor.goto_first_child: function(Cursor): boolean </code></a></h2><p>Position the cursor at the first child of the current node</p><br><h2><a id="Cursor.goto_next_sibling"><code>Cursor.goto_next_sibling: function(Cursor): boolean </code></a></h2><p>Position the cursor at the sibling of the current node</p><br><h2><a id="Cursor.goto_parent"><code>Cursor.goto_parent: function(Cursor): boolean </code></a></h2><p>Position the cursor at the parent of the current node</p><br><h2><a id="Cursor.reset"><code>Cursor.reset: function(Cursor, Node) </code></a></h2><p>Position the cursor at the given node</p><br><br><h2><a id="Node.child"><code>Node.child: function(Node, idx: number): Node </code></a></h2><p>Get the node's idx'th child (0-indexed)</p><br><h2><a id="Node.child_by_field_name"><code>Node.child_by_field_name: function(Node, string): Node </code></a></h2><p>Get a node's child given a field name</p><br><h2><a id="Node.child_count"><code>Node.child_count: function(Node): number </code></a></h2><p>Get the number of children a node has</p><br><h2><a id="Node.children"><code>Node.children: function(Node): function(): Node </code></a></h2><p>Iterate over a node's children</p><br><h2><a id="Node.create_cursor"><code>Node.create_cursor: function(Node): Cursor </code></a></h2><p>Create a new cursor at the given node</p><br><h2><a id="Node.end_byte"><code>Node.end_byte: function(Node): number </code></a></h2><p>Get the byte of the source string that the given node ends at</p><br><h2><a id="Node.end_point"><code>Node.end_point: function(Node): Point </code></a></h2><p>Get the row and column of where the given node ends</p><br><h2><a id="Node.is_extra"><code>Node.is_extra: function(Node): boolean </code></a></h2><p>Get whether or not the current node is missing</p><br><h2><a id="Node.is_missing"><code>Node.is_missing: function(Node): boolean </code></a></h2><p>Get whether or not the current node is missing</p><br><h2><a id="Node.is_named"><code>Node.is_named: function(Node): boolean </code></a></h2><p>Get whether or not the current node is named</p><br><h2><a id="Node.name"><code>Node.name: function(Node): string </code></a></h2><p>Returns the name of a given node<br>   <pre><br>   print(node) -- => (comment)<br>   print(node:name()) -- => comment<br>   </pre></p><br><h2><a id="Node.named_child"><code>Node.named_child: function(Node, idx: number): Node </code></a></h2><p>Get the node's idx'th named child (0-indexed)</p><br><h2><a id="Node.named_child_count"><code>Node.named_child_count: function(Node): number </code></a></h2><p>Get the number of named children a node has</p><br><h2><a id="Node.named_children"><code>Node.named_children: function(Node): function(): Node </code></a></h2><p>Iterate over a node's named children</p><br><h2><a id="Node.next_named_sibling"><code>Node.next_named_sibling: function(Node): Node </code></a></h2><p>Get a node's next named sibling</p><br><h2><a id="Node.next_sibling"><code>Node.next_sibling: function(Node): Node </code></a></h2><p>Get a node's next sibling</p><br><h2><a id="Node.prev_named_sibling"><code>Node.prev_named_sibling: function(Node): Node </code></a></h2><p>Get a node's previous named sibling</p><br><h2><a id="Node.prev_sibling"><code>Node.prev_sibling: function(Node): Node </code></a></h2><p>Get a node's previous sibling</p><br><h2><a id="Node.source"><code>Node.source: function(Node): string </code></a></h2><p>Get the substring of the source that was parsed to create <code>Node</code></p><br><h2><a id="Node.start_byte"><code>Node.start_byte: function(Node): number </code></a></h2><p>Get the byte of the source string that the given node starts at</p><br><h2><a id="Node.start_point"><code>Node.start_point: function(Node): Point </code></a></h2><p>Get the row and column of where the given node starts</p><br><h2><a id="Node.type"><code>Node.type: function(Node): string </code></a></h2><p>Get the type of the given node</p><br><br><h2><a id="Parser.parse_string"><code>Parser.parse_string: function(Parser, string, Tree): Tree </code></a></h2><p>Uses the given parser to parse the string<br><br>   If Tree is provided then it will be used to create a new updated tree<br>   (but it is the responsibility of the programmer to make the correct <code>Tree:edit</code> calls)<br><br>   Could return nil if the parser has a timeout</p><br><h2><a id="Parser.query"><code>Parser.query: function(Parser, string): Query </code></a></h2><p>Create a query out of the given string for the language of the given parser</p><br><h2><a id="Parser.set_timeout"><code>Parser.set_timeout: function(Parser, number) </code></a></h2><p>Sets how long the parser is allowed to take in microseconds</p><br><br><h2><a id="Query.capture"><code>Query.capture: function(Query, Node): function(): Node, string </code></a></h2><p>Iterate over the captures of a given query in <code>Node</code>, <code>name</code> pairs<br><br>   <pre><br>   local q = parser:query[[ (comment) @my_match ]]<br>   for capture, name in q:capture(node) do<br>      print(capture, name) -- => (comment), "my_match"<br>   end<br>   </pre></p><br><h2><a id="Query.exec"><code>Query.exec: function(Query, Node) </code></a></h2><p>Runs a query. That's it. Nothing more, nothing less.<br>   This is intended to be used with the <code>Query.with</code> method and predicates that have side effects,<br>   i.e. for when you would use Query.match or Query.capture, but do nothing in the for loop.<br><br>   <pre><br>   local parser = ltreesitter.require("teal")<br><br>   -- grab a node to query against<br>   local root_node = parser:parse_string[[<br>   local x: string = "foo"<br>   local y: string = "bar"<br>   ]]:root()<br><br>   parser<br>      :query[[(<br>         (var_declaration<br>            (var) @var-name<br>            (string) @value)<br>         (#set! @var-name @value)<br>      )]]<br>      :with{["set!"] = function(a, b) _G[a] = b:sub(2, -2) end}<br>      :exec(root_node)<br><br>   print(x) -- => foo<br>   print(y) -- => bar<br><br>   </pre><br><br>   If you'd like to interact with the matches/captures of a query, see the Query.match and Query.capture iterators</p><br><h2><a id="Query.match"><code>Query.match: function(Query, Node): function(): Match </code></a></h2><p>Iterate over the matches of a given query<br><br>   The match object is a record populated with all the information given by treesitter<br>   <pre><br>   type Query.Match = record<br>      id: number<br>      pattern_index: number<br>      capture_count: number<br>      captures: {string|number:Node}<br>   end<br>   </pre><br><br>   Example:<br>   <pre><br>   local q = parser:query[[ (comment) @my_match ]]<br>   for match in q:match(node) do<br>      print(match.captures.my_match)<br>   end<br>   </pre></p><br><h2><a id="Query.with"><code>Query.with: function(Query, {string:function(...: string): any...}): Query </code></a></h2><p>Creates a new query equipped with predicates defined in the <code>{string:function}</code> map given<br><br>   Predicates that end in a <code>'?'</code> character will be seen as conditions that must be met for the pattern to be matched.<br>   Predicates that don't will be seen just as functions to be executed given the matches provided.<br><br>   Additionally, you will not have access to the return values of these functions, if you'd like to keep the results of a computation, make your functions have side-effects to write somewhere you can access.<br><br>   By default the following predicates are provided.<br>      <code> (#eq? ...) </code> will match if all arguments provided are equal<br>      <code> (#match? text pattern) </code> will match the provided <code>text</code> matches the given <code>pattern</code>. Matches are determined by Lua's standard <code>string.match</code> function.<br>      <code> (#find? text substring) </code> will match if <code>text</code> contains <code>substring</code>. The substring is found with Lua's standard <code>string.find</code>, but the search always starts from the beginning, and pattern matching is disabled. This is equivalent to <code>string.find(text, substring, 0, true)</code><br><br>   Example:<br>   The following snippet will match lua functions that have a single LDoc/EmmyLua style comment above them<br>   <pre><br>   local parser = ltreesitter.require("lua")<br><br>   -- grab a node to query against<br>   local root_node = parser:parse_string[[<br>      ---@Doc this does stuff<br>      local function stuff_doer()<br>         do_stuff()<br>      end<br>   ]]:root()<br><br>   for match in parser<br>      :query[[(<br>         (comment) @the-comment<br>         .<br>         (function_definition<br>            (function_name) @the-function-name)<br>         (#is_doc_comment? @the-comment)<br>      )]]<br>      :with{<br>         ["is_doc_comment?"] = function(str)<br>            return str:sub(1, 4) == "---@"<br>         end<br>      }<br>      :match(root_node)<br>   do<br>      print("Function: " .. match.captures["the-function-name"] .. " has documentation")<br>      print("   " .. match.captures["the-comment"])<br>   end<br>   </pre></p><br><br><h2><a id="Tree.copy"><code>Tree.copy: function(Tree): Tree </code></a></h2><p>Creates a copy of the tree. Tree-sitter recommends to create copies if you are going to use multithreading since tree accesses are not thread-safe, but copying them is cheap and quick</p><br><h2><a id="Tree.edit"><code>Tree.edit: function(Tree, TreeEdit) </code></a></h2><p>Create an edit to the given tree</p><br><h2><a id="Tree.root"><code>Tree.root: function(Tree): Node </code></a></h2><p>Returns the root node of the given parse tree</p></body></html>