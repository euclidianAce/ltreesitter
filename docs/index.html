<html>
<style>
html {
   background-color: #16191a;
}

body {
   background-color: #181a1b;
   margin: auto;
   max-width: 70em;
   width: 90%;
   padding: 32px;
   font-family: Helvetica, Arial, sans-serif;
   color: #e8e6e3;
}

a {
   text-decoration: none;
   color: #3391ff;
}

h2 {
   color: #117dee;
}

</style>
<body>
<table width="100%">
<tbody>
<tr>
<td valign=top>
<h4>ltreesitter</h4>
<p>
<a href="index.html#load">load</a>
<br>
<a href="index.html#require">require</a>
<br>
</p>
<h4>Cursor</h4>
<p>
<a href="index.html#Cursor.current_field_name">Cursor.current_field_name</a>
<br>
<a href="index.html#Cursor.current_node">Cursor.current_node</a>
<br>
<a href="index.html#Cursor.goto_first_child">Cursor.goto_first_child</a>
<br>
<a href="index.html#Cursor.goto_first_child_for_byte">Cursor.goto_first_child_for_byte</a>
<br>
<a href="index.html#Cursor.goto_next_sibling">Cursor.goto_next_sibling</a>
<br>
<a href="index.html#Cursor.goto_parent">Cursor.goto_parent</a>
<br>
<a href="index.html#Cursor.reset">Cursor.reset</a>
<br>
</p>
<h4>Node</h4>
<p>
<a href="index.html#Node.child">Node.child</a>
<br>
<a href="index.html#Node.child_by_field_name">Node.child_by_field_name</a>
<br>
<a href="index.html#Node.child_count">Node.child_count</a>
<br>
<a href="index.html#Node.children">Node.children</a>
<br>
<a href="index.html#Node.create_cursor">Node.create_cursor</a>
<br>
<a href="index.html#Node.end_byte">Node.end_byte</a>
<br>
<a href="index.html#Node.end_point">Node.end_point</a>
<br>
<a href="index.html#Node.is_extra">Node.is_extra</a>
<br>
<a href="index.html#Node.is_missing">Node.is_missing</a>
<br>
<a href="index.html#Node.is_named">Node.is_named</a>
<br>
<a href="index.html#Node.name">Node.name</a>
<br>
<a href="index.html#Node.named_child">Node.named_child</a>
<br>
<a href="index.html#Node.named_child_count">Node.named_child_count</a>
<br>
<a href="index.html#Node.named_children">Node.named_children</a>
<br>
<a href="index.html#Node.next_named_sibling">Node.next_named_sibling</a>
<br>
<a href="index.html#Node.next_sibling">Node.next_sibling</a>
<br>
<a href="index.html#Node.prev_named_sibling">Node.prev_named_sibling</a>
<br>
<a href="index.html#Node.prev_sibling">Node.prev_sibling</a>
<br>
<a href="index.html#Node.source">Node.source</a>
<br>
<a href="index.html#Node.start_byte">Node.start_byte</a>
<br>
<a href="index.html#Node.start_point">Node.start_point</a>
<br>
<a href="index.html#Node.type">Node.type</a>
<br>
</p>
</td>
<td valign=top>
<h4>Parser</h4>
<p>
<a href="index.html#Parser.get_ranges">Parser.get_ranges</a>
<br>
<a href="index.html#Parser.get_version">Parser.get_version</a>
<br>
<a href="index.html#Parser.parse_string">Parser.parse_string</a>
<br>
<a href="index.html#Parser.parse_with">Parser.parse_with</a>
<br>
<a href="index.html#Parser.query">Parser.query</a>
<br>
<a href="index.html#Parser.set_ranges">Parser.set_ranges</a>
<br>
<a href="index.html#Parser.set_timeout">Parser.set_timeout</a>
<br>
</p>
<h4>Query</h4>
<p>
<a href="index.html#Query.capture">Query.capture</a>
<br>
<a href="index.html#Query.exec">Query.exec</a>
<br>
<a href="index.html#Query.match">Query.match</a>
<br>
<a href="index.html#Query.with">Query.with</a>
<br>
</p>
<h4>Tree</h4>
<p>
<a href="index.html#Tree.copy">Tree.copy</a>
<br>
<a href="index.html#Tree.edit">Tree.edit</a>
<br>
<a href="index.html#Tree.edit_s">Tree.edit_s</a>
<br>
<a href="index.html#Tree.get_changed_ranges">Tree.get_changed_ranges</a>
<br>
<a href="index.html#Tree.root">Tree.root</a>
<br>
</p></td></tr></tbody></table>
<br><br><br><br><br><br><br><br><br><br>
<h2><a name="load"><code>load: function(file_name: string, language_name: string): Parser, string </code></a></h2>
<p>Load a parser from a given file<br><br>   Keep in mind that this includes the <code>.so</code> or <code>.dll</code> extension<br><br>   On Unix this uses dlopen, on Windows this uses LoadLibrary so if a path without a path separator is given, these functions have their own path's that they will search for your file in.<br>   So if in doubt use a file path like<br>   <pre><br>   local my_parser = ltreesitter.load("./my_parser.so", "my_language")<br>   </pre></p><br>
<h2><a name="require"><code>require: function(library_file_name: string, language_name: string): Parser </code></a></h2>
<p>Search <code>~/.tree-sitter/bin</code> and <code>package.cpath</code> for a parser with the filename <code>library_file_name.so</code> (or <code>.dll</code> on Windows) and try to load the symbol <code>tree_sitter_'language_name'</code><br>   <code>language_name</code> is optional and will be set to <code>library_file_name</code> if not provided.<br><br>   So if you want to load a Lua parser from a file named <code>lua.so</code> then use <code>ltreesitter.require("lua")</code><br>   But if you want to load a Lua parser from a file named <code>parser.so</code> then use <code>ltreesitter.require("parser", "lua")</code><br><br>   Like the regular <code>require</code>, this will error if the parser is not found or the symbol couldn't be loaded. Use either <code>pcall</code> or <code>ltreesitter.load</code> to not error out on failure.<br><br>   <pre><br>   local my_parser = ltreesitter.require("my_language")<br>   my_parser:parse_string(...)<br>   -- etc.<br>   </pre></p><br>
<br>
<h2><a name="Cursor.current_field_name"><code>Cursor.current_field_name: function(Cursor): string </code></a></h2>
<p>Get the field name of the current node under the cursor</p><br>
<h2><a name="Cursor.current_node"><code>Cursor.current_node: function(Cursor): Node </code></a></h2>
<p>Get the current node under the cursor</p><br>
<h2><a name="Cursor.goto_first_child"><code>Cursor.goto_first_child: function(Cursor): boolean </code></a></h2>
<p>Position the cursor at the first child of the current node</p><br>
<h2><a name="Cursor.goto_first_child_for_byte"><code>Cursor.goto_first_child_for_byte: function(Cursor, integer): integer </code></a></h2>
<p>Move the given cursor to the first child of its current node that extends<br>   beyond the given byte offset.<br><br>   Returns the index of the found node, if a node wasn't found, returns nil</p><br>
<h2><a name="Cursor.goto_next_sibling"><code>Cursor.goto_next_sibling: function(Cursor): boolean </code></a></h2>
<p>Position the cursor at the sibling of the current node</p><br>
<h2><a name="Cursor.goto_parent"><code>Cursor.goto_parent: function(Cursor): boolean </code></a></h2>
<p>Position the cursor at the parent of the current node</p><br>
<h2><a name="Cursor.reset"><code>Cursor.reset: function(Cursor, Node) </code></a></h2>
<p>Position the cursor at the given node</p><br>
<br>
<h2><a name="Node.child"><code>Node.child: function(Node, idx: integer): Node </code></a></h2>
<p>Get the node's idx'th child (0-indexed)</p><br>
<h2><a name="Node.child_by_field_name"><code>Node.child_by_field_name: function(Node, string): Node </code></a></h2>
<p>Get a node's child given a field name</p><br>
<h2><a name="Node.child_count"><code>Node.child_count: function(Node): integer </code></a></h2>
<p>Get the number of children a node has</p><br>
<h2><a name="Node.children"><code>Node.children: function(Node): function(): Node </code></a></h2>
<p>Iterate over a node's children</p><br>
<h2><a name="Node.create_cursor"><code>Node.create_cursor: function(Node): Cursor </code></a></h2>
<p>Create a new cursor at the given node</p><br>
<h2><a name="Node.end_byte"><code>Node.end_byte: function(Node): integer </code></a></h2>
<p>Get the byte of the source string that the given node ends at</p><br>
<h2><a name="Node.end_point"><code>Node.end_point: function(Node): Point </code></a></h2>
<p>Get the row and column of where the given node ends</p><br>
<h2><a name="Node.is_extra"><code>Node.is_extra: function(Node): boolean </code></a></h2>
<p>Get whether or not the current node is extra</p><br>
<h2><a name="Node.is_missing"><code>Node.is_missing: function(Node): boolean </code></a></h2>
<p>Get whether or not the current node is missing</p><br>
<h2><a name="Node.is_named"><code>Node.is_named: function(Node): boolean </code></a></h2>
<p>Get whether or not the current node is named</p><br>
<h2><a name="Node.name"><code>Node.name: function(Node): string </code></a></h2>
<p>Returns the name of a given node<br>   <pre><br>   print(node) -- => (comment)<br>   print(node:name()) -- => comment<br>   </pre></p><br>
<h2><a name="Node.named_child"><code>Node.named_child: function(Node, idx: integer): Node </code></a></h2>
<p>Get the node's idx'th named child (0-indexed)</p><br>
<h2><a name="Node.named_child_count"><code>Node.named_child_count: function(Node): integer </code></a></h2>
<p>Get the number of named children a node has</p><br>
<h2><a name="Node.named_children"><code>Node.named_children: function(Node): function(): Node </code></a></h2>
<p>Iterate over a node's named children</p><br>
<h2><a name="Node.next_named_sibling"><code>Node.next_named_sibling: function(Node): Node </code></a></h2>
<p>Get a node's next named sibling</p><br>
<h2><a name="Node.next_sibling"><code>Node.next_sibling: function(Node): Node </code></a></h2>
<p>Get a node's next sibling</p><br>
<h2><a name="Node.prev_named_sibling"><code>Node.prev_named_sibling: function(Node): Node </code></a></h2>
<p>Get a node's previous named sibling</p><br>
<h2><a name="Node.prev_sibling"><code>Node.prev_sibling: function(Node): Node </code></a></h2>
<p>Get a node's previous sibling</p><br>
<h2><a name="Node.source"><code>Node.source: function(Node): string </code></a></h2>
<p>Get the substring of the source that was parsed to create <code>Node</code></p><br>
<h2><a name="Node.start_byte"><code>Node.start_byte: function(Node): integer </code></a></h2>
<p>Get the byte of the source string that the given node starts at</p><br>
<h2><a name="Node.start_point"><code>Node.start_point: function(Node): Point </code></a></h2>
<p>Get the row and column of where the given node starts</p><br>
<h2><a name="Node.type"><code>Node.type: function(Node): string </code></a></h2>
<p>Get the type of the given node</p><br>
<br>
<h2><a name="Parser.get_ranges"><code>Parser.get_ranges: function(Parser): {Range} </code></a></h2>
<p>Get the ranges of text that the parser will include when parsing</p><br>
<h2><a name="Parser.get_version"><code>Parser.get_version: function(Parser): integer </code></a></h2>
<p>get the api version of the parser's language</p><br>
<h2><a name="Parser.parse_string"><code>Parser.parse_string: function(Parser, string, Tree): Tree </code></a></h2>
<p>Uses the given parser to parse the string<br><br>   If <code>Tree</code> is provided then it will be used to create a new updated tree<br>   (but it is the responsibility of the programmer to make the correct <code>Tree:edit</code> calls)<br><br>   Could return <code>nil</code> if the parser has a timeout</p><br>
<h2><a name="Parser.parse_with"><code>Parser.parse_with: function(Parser, reader: function(integer, Point): (string), old_tree: Tree): Tree </code></a></h2>
<p><code>reader</code> should be a function that takes a byte index<br>   and a <code>Point</code> and returns the text at that point. The<br>   function should return either <code>nil</code> or an empty string<br>   to signal that there is no more text.<br><br>   A <code>Tree</code> can be provided to reuse parts of it for parsing,<br>   provided the <code>Tree:edit</code> has been called previously</p><br>
<h2><a name="Parser.query"><code>Parser.query: function(Parser, string): Query </code></a></h2>
<p>Create a query out of the given string for the language of the given parser</p><br>
<h2><a name="Parser.set_ranges"><code>Parser.set_ranges: function(Parser, {Range}): boolean </code></a></h2>
<p>Sets the ranges that <code>Parser</code> will include when parsing, so you don't have to parse an entire document, but the ranges in the tree will still match the document.<br>   The array of <code>Range</code>s must satisfy the following relationship: for a positive integer <code>i</code> within the length of <code>ranges: {Range}</code>:<br>   <pre><br>   ranges[i].end_byte <= ranges[i + 1].start_byte<br>   </pre><br><br>   returns whether or not setting the range succeeded</p><br>
<h2><a name="Parser.set_timeout"><code>Parser.set_timeout: function(Parser, integer) </code></a></h2>
<p>Sets how long the parser is allowed to take in microseconds</p><br>
<br>
<h2><a name="Query.capture"><code>Query.capture: function(Query, Node, start: integer | Point, end_: integer | Point): function(): (Node, string) </code></a></h2>
<p>Iterate over the captures of a given query in <code>Node</code>, <code>name</code> pairs.<br>   <code>start</code> and <code>end</code> are optional.<br>   They must be passed together with the same type, describing either two bytes or two points.<br>   If passed, the query will be executed within the range denoted.<br>   If not passed, the default behaviour is to execute the query through the entire range of the node.<br><br>   <pre><br>   local q = parser:query[[ (comment) @my_match ]]<br>   for capture, name in q:capture(node) do<br>      print(capture, name) -- => (comment), "my_match"<br>   end<br>   </pre></p><br>
<h2><a name="Query.exec"><code>Query.exec: function(Query, Node, start: integer | Point, end_: integer | Point) </code></a></h2>
<p>Runs a query. That's it. Nothing more, nothing less.<br>   This is intended to be used with the <code>Query.with</code> method and predicates that have side effects,<br>   i.e. for when you would use Query.match or Query.capture, but do nothing in the for loop.<br>   <code>start</code> and <code>end</code> are optional.<br>   They must be passed together with the same type, describing either two bytes or two points.<br>   If passed, the query will be executed within the range denoted.<br>   If not passed, the default behaviour is to execute the query through the entire range of the node.<br><br>   <pre><br>   local parser = ltreesitter.require("teal")<br><br>   -- grab a node to query against<br>   local root_node = parser:parse_string[[<br>   local x: string = "foo"<br>   local y: string = "bar"<br>   ]]:root()<br><br>   parser<br>      :query[[(<br>         (var_declaration<br>            (var) @var-name<br>            (string) @value)<br>         (#set! @var-name @value)<br>      )]]<br>      :with{["set!"] = function(a, b) _G[a] = b:sub(2, -2) end}<br>      :exec(root_node)<br><br>   print(x) -- => foo<br>   print(y) -- => bar<br><br>   </pre><br><br>   If you'd like to interact with the matches/captures of a query, see the Query.match and Query.capture iterators</p><br>
<h2><a name="Query.match"><code>Query.match: function(Query, Node, start: integer | Point, end_: integer | Point): function(): Match </code></a></h2>
<p>Iterate over the matches of a given query.<br>   <code>start</code> and <code>end</code> are optional.<br>   They must be passed together with the same type, describing either two bytes or two points.<br>   If passed, the query will be executed within the range denoted.<br>   If not passed, the default behaviour is to execute the query through the entire range of the node.<br><br>   The match object is a record populated with all the information given by treesitter<br>   <pre><br>   type Match = record<br>      id: integer<br>      pattern_index: integer<br>      capture_count: integer<br>      captures: {string|integer:Node}<br>   end<br>   </pre><br><br>   Example:<br>   <pre><br>   local q = parser:query[[ (comment) @my_match ]]<br>   for match in q:match(node) do<br>      print(match.captures.my_match)<br>   end<br>   </pre></p><br>
<h2><a name="Query.with"><code>Query.with: function(Query, {string:function(...: string | Node | {Node}): any...}): Query </code></a></h2>
<p>Creates a new query equipped with predicates defined in the <code>{string:function}</code> map given<br><br>   Predicates that end in a <code>'?'</code> character will be seen as conditions that must be met for the pattern to be matched.<br>   Predicates that don't will be seen just as functions to be executed given the matches provided.<br><br>   Additionally, you will not have access to the return values of these functions, if you'd like to keep the results of a computation, make your functions have side-effects to write somewhere you can access.<br><br>   By default the following predicates are provided.<br>      <code> (#eq? ...) </code> will match if all arguments provided are equal<br>      <code> (#match? text pattern) </code> will match the provided <code>text</code> matches the given <code>pattern</code>. Matches are determined by Lua's standard <code>string.match</code> function.<br>      <code> (#find? text substring) </code> will match if <code>text</code> contains <code>substring</code>. The substring is found with Lua's standard <code>string.find</code>, but the search always starts from the beginning, and pattern matching is disabled. This is equivalent to <code>string.find(text, substring, 0, true)</code><br><br>   Example:<br>   The following snippet will match lua functions that have a single LDoc/EmmyLua style comment above them<br>   <pre><br>   local parser = ltreesitter.require("lua")<br><br>   -- grab a node to query against<br>   local root_node = parser:parse_string[[<br>      ---@Doc this does stuff<br>      local function stuff_doer()<br>         do_stuff()<br>      end<br>   ]]:root()<br><br>   for match in parser<br>      :query[[(<br>         (comment) @the-comment<br>         .<br>         (function_definition<br>            (function_name) @the-function-name)<br>         (#is_doc_comment? @the-comment)<br>      )]]<br>      :with{<br>         ["is_doc_comment?"] = function(str)<br>            return str:sub(1, 4) == "---@"<br>         end<br>      }<br>      :match(root_node)<br>   do<br>      print("Function: " .. match.captures["the-function-name"] .. " has documentation")<br>      print("   " .. match.captures["the-comment"])<br>   end<br>   </pre></p><br>
<br>
<h2><a name="Tree.copy"><code>Tree.copy: function(Tree): Tree </code></a></h2>
<p>Creates a copy of the tree. Tree-sitter recommends to create copies if you are going to use multithreading since tree accesses are not thread-safe, but copying them is cheap and quick</p><br>
<h2><a name="Tree.edit"><code>Tree.edit: function(
         Tree,
         start_byte: integer,
         old_end_byte: integer,
         new_end_byte: integer,
         start_point_row: integer,
         start_point_col: integer,
         old_end_point_row: integer,
         old_end_point_col: integer,
         new_end_point_row: integer,
         new_end_point_col: integer
      ) </code></a></h2>
<p>Create an edit to the given tree</p><br>
<h2><a name="Tree.edit_s"><code>Tree.edit_s: function(Tree, TreeEdit) </code></a></h2>
<p>Create an edit to the given tree</p><br>
<h2><a name="Tree.get_changed_ranges"><code>Tree.get_changed_ranges: function(old: Tree, new: Tree): {Range} </code></a></h2>
<p>Compare an old syntax tree to a new syntax tree.<br>   This would usually be called right after a set of calls to <code>Tree.edit(_s)</code> and <code>Parser.parse_{string,with}</code></p><br>
<h2><a name="Tree.root"><code>Tree.root: function(Tree): Node </code></a></h2>
<p>Returns the root node of the given parse tree</p><br>
</body></html>
