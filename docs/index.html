<html>
<style>
html {
   background-color: #16191a;
}

body {
   background-color: #181a1b;
   margin: auto;
   max-width: 70em;
   width: 90%;
   padding: 32px;
   font-family: Helvetica, Arial, sans-serif;
   color: #e8e6e3;
}

a {
   text-decoration: none;
   color: #3391ff;
}

h2 {
   color: #117dee;
}

</style>
<body>
<table width="100%">
<tbody>
<tr>
<td valign=top>
<h4>ltreesitter</h4>
<p>
<a href="index.html#load">load</a>
<br>
<a href="index.html#require">require</a>
<br>
</p>
<h4>Cursor</h4>
<p>
<a href="index.html#Cursor.copy">Cursor.copy</a>
<br>
<a href="index.html#Cursor.current_depth">Cursor.current_depth</a>
<br>
<a href="index.html#Cursor.current_descendant_index">Cursor.current_descendant_index</a>
<br>
<a href="index.html#Cursor.current_field_id">Cursor.current_field_id</a>
<br>
<a href="index.html#Cursor.current_field_name">Cursor.current_field_name</a>
<br>
<a href="index.html#Cursor.current_node">Cursor.current_node</a>
<br>
<a href="index.html#Cursor.goto_descendant">Cursor.goto_descendant</a>
<br>
<a href="index.html#Cursor.goto_first_child">Cursor.goto_first_child</a>
<br>
<a href="index.html#Cursor.goto_first_child_for_byte">Cursor.goto_first_child_for_byte</a>
<br>
<a href="index.html#Cursor.goto_first_child_for_point">Cursor.goto_first_child_for_point</a>
<br>
<a href="index.html#Cursor.goto_next_sibling">Cursor.goto_next_sibling</a>
<br>
<a href="index.html#Cursor.goto_parent">Cursor.goto_parent</a>
<br>
<a href="index.html#Cursor.reset">Cursor.reset</a>
<br>
<a href="index.html#Cursor.reset_to">Cursor.reset_to</a>
<br>
</p>
<h4>Language</h4>
<p>
<a href="index.html#Language.abi_version">Language.abi_version</a>
<br>
<a href="index.html#Language.field_count">Language.field_count</a>
<br>
<a href="index.html#Language.field_id_for_name">Language.field_id_for_name</a>
<br>
<a href="index.html#Language.metadata">Language.metadata</a>
<br>
<a href="index.html#Language.name">Language.name</a>
<br>
<a href="index.html#Language.name_for_field_id">Language.name_for_field_id</a>
<br>
<a href="index.html#Language.next_state">Language.next_state</a>
<br>
<a href="index.html#Language.parser">Language.parser</a>
<br>
<a href="index.html#Language.query">Language.query</a>
<br>
<a href="index.html#Language.state_count">Language.state_count</a>
<br>
<a href="index.html#Language.subtypes">Language.subtypes</a>
<br>
<a href="index.html#Language.supertypes">Language.supertypes</a>
<br>
<a href="index.html#Language.symbol_count">Language.symbol_count</a>
<br>
<a href="index.html#Language.symbol_for_name">Language.symbol_for_name</a>
<br>
<a href="index.html#Language.symbol_name">Language.symbol_name</a>
<br>
<a href="index.html#Language.symbol_type">Language.symbol_type</a>
<br>
</p>
</td>
<td valign=top>
<h4>Node</h4>
<p>
<a href="index.html#Node.child">Node.child</a>
<br>
<a href="index.html#Node.child_by_field_id">Node.child_by_field_id</a>
<br>
<a href="index.html#Node.child_by_field_name">Node.child_by_field_name</a>
<br>
<a href="index.html#Node.child_count">Node.child_count</a>
<br>
<a href="index.html#Node.children">Node.children</a>
<br>
<a href="index.html#Node.create_cursor">Node.create_cursor</a>
<br>
<a href="index.html#Node.end_byte">Node.end_byte</a>
<br>
<a href="index.html#Node.end_point">Node.end_point</a>
<br>
<a href="index.html#Node.grammar_symbol">Node.grammar_symbol</a>
<br>
<a href="index.html#Node.grammar_type">Node.grammar_type</a>
<br>
<a href="index.html#Node.is_extra">Node.is_extra</a>
<br>
<a href="index.html#Node.is_missing">Node.is_missing</a>
<br>
<a href="index.html#Node.is_named">Node.is_named</a>
<br>
<a href="index.html#Node.name">Node.name</a>
<br>
<a href="index.html#Node.named_child">Node.named_child</a>
<br>
<a href="index.html#Node.named_child_count">Node.named_child_count</a>
<br>
<a href="index.html#Node.named_children">Node.named_children</a>
<br>
<a href="index.html#Node.next_named_sibling">Node.next_named_sibling</a>
<br>
<a href="index.html#Node.next_parse_state">Node.next_parse_state</a>
<br>
<a href="index.html#Node.next_sibling">Node.next_sibling</a>
<br>
<a href="index.html#Node.parse_state">Node.parse_state</a>
<br>
<a href="index.html#Node.prev_named_sibling">Node.prev_named_sibling</a>
<br>
<a href="index.html#Node.prev_sibling">Node.prev_sibling</a>
<br>
<a href="index.html#Node.source">Node.source</a>
<br>
<a href="index.html#Node.start_byte">Node.start_byte</a>
<br>
<a href="index.html#Node.start_point">Node.start_point</a>
<br>
<a href="index.html#Node.symbol">Node.symbol</a>
<br>
<a href="index.html#Node.type">Node.type</a>
<br>
</p>
</td>
<td valign=top>
<h4>Parser</h4>
<p>
<a href="index.html#Parser.get_ranges">Parser.get_ranges</a>
<br>
<a href="index.html#Parser.parse_string">Parser.parse_string</a>
<br>
<a href="index.html#Parser.parse_with">Parser.parse_with</a>
<br>
<a href="index.html#Parser.reset">Parser.reset</a>
<br>
<a href="index.html#Parser.set_ranges">Parser.set_ranges</a>
<br>
</p>
<h4>Query</h4>
<p>
<a href="index.html#Query._with">Query._with</a>
<br>
<a href="index.html#Query.capture">Query.capture</a>
<br>
<a href="index.html#Query.exec">Query.exec</a>
<br>
<a href="index.html#Query.match">Query.match</a>
<br>
</p>
<h4>Tree</h4>
<p>
<a href="index.html#Tree.copy">Tree.copy</a>
<br>
<a href="index.html#Tree.edit">Tree.edit</a>
<br>
<a href="index.html#Tree.edit_s">Tree.edit_s</a>
<br>
<a href="index.html#Tree.get_changed_ranges">Tree.get_changed_ranges</a>
<br>
<a href="index.html#Tree.root">Tree.root</a>
<br>
</p></td></tr></tbody></table>
<br><br><br><br><br><br><br><br><br><br>
<h2><a name="load"><code>load: function(file_name: string, language_name: string): Language, string</code></a></h2>
<p>Load a language from a given file<br><br>   Keep in mind that this includes the <code>.so</code>, <code>.dll</code>, or <code>.dynlib</code> extension<br><br>   On Unix this uses dlopen, on Windows this uses LoadLibrary so if a path without a path separator is given, these functions have their own path's that they will search for your file in.<br>   So if in doubt use a file path like<br>   <pre><br>   local my_language = ltreesitter.load("./my_parser.so", "my_language")<br>   </pre></p><br>
<h2><a name="require"><code>require: function(library_file_name: string, language_name?: string): Language, string</code></a></h2>
<p>Search <code>package.cpath</code> for a parser with the filename <code>library_file_name.so</code> or <code>parsers/library_file_name.so</code> (or <code>.dll</code> on Windows) and try to load the symbol <code>tree_sitter_'language_name'</code><br>   <code>language_name</code> is optional and will be set to <code>library_file_name</code> if not provided.<br><br>   So if you want to load a Lua parser from a file named <code>lua.so</code> then use <code>ltreesitter.require("lua")</code><br>   But if you want to load a Lua parser from a file named <code>parser.so</code> then use <code>ltreesitter.require("parser", "lua")</code><br><br>   Like the regular <code>require</code>, this will error if the parser is not found or the symbol couldn't be loaded. Use either <code>pcall</code> or <code>ltreesitter.load</code> to not error out on failure.<br><br>   Returns the language and the path it was loaded from.<br><br>   <pre><br>   local my_language, loaded_from = ltreesitter.require("my_language")<br>   print(my_language:name(), loaded_from) -- "my_language", /home/user/.luarocks/lib/lua/5.4/parsers/my_language.so<br>   -- etc.<br>   </pre></p><br>
<br>
<h2><a name="Cursor.copy"><code>Cursor.copy: function(Cursor): Cursor</code></a></h2>
<p>Create a copy of the given cursor</p><br>
<h2><a name="Cursor.current_depth"><code>Cursor.current_depth: function(Cursor): integer</code></a></h2>
<p>Get the depth of the cursor's current node relative to the node the cursor<br>   was constructed with</p><br>
<h2><a name="Cursor.current_descendant_index"><code>Cursor.current_descendant_index: function(Cursor): integer</code></a></h2>
<p>Get the cursor's current node index</p><br>
<h2><a name="Cursor.current_field_id"><code>Cursor.current_field_id: function(Cursor): FieldId</code></a></h2>
<p>Get the field id of the given cursor's current node<br><br>   May return nil</p><br>
<h2><a name="Cursor.current_field_name"><code>Cursor.current_field_name: function(Cursor): string</code></a></h2>
<p>Get the field name of the current node under the cursor</p><br>
<h2><a name="Cursor.current_node"><code>Cursor.current_node: function(Cursor): Node</code></a></h2>
<p>Get the current node under the cursor</p><br>
<h2><a name="Cursor.goto_descendant"><code>Cursor.goto_descendant: function(Cursor, integer)</code></a></h2>
<p>Move the cursor to the nth descendant of the original node this cursor was<br>   constructed with. Zero represents the original node itself.</p><br>
<h2><a name="Cursor.goto_first_child"><code>Cursor.goto_first_child: function(Cursor): boolean</code></a></h2>
<p>Position the cursor at the first child of the current node</p><br>
<h2><a name="Cursor.goto_first_child_for_byte"><code>Cursor.goto_first_child_for_byte: function(Cursor, integer): integer</code></a></h2>
<p>Move the given cursor to the first child of its current node that contains<br>   or starts after the given offset<br><br>   Returns the index of the child node or nil if no such child was found</p><br>
<h2><a name="Cursor.goto_first_child_for_point"><code>Cursor.goto_first_child_for_point: function(Cursor, Point): integer</code></a></h2>
<p>Move the given cursor to the first child of its current node that contains<br>   or starts after the given point<br><br>   Returns the index of the child node or nil if no such child was found</p><br>
<h2><a name="Cursor.goto_next_sibling"><code>Cursor.goto_next_sibling: function(Cursor): boolean</code></a></h2>
<p>Position the cursor at the sibling of the current node</p><br>
<h2><a name="Cursor.goto_parent"><code>Cursor.goto_parent: function(Cursor): boolean</code></a></h2>
<p>Position the cursor at the parent of the current node</p><br>
<h2><a name="Cursor.reset"><code>Cursor.reset: function(Cursor, Node)</code></a></h2>
<p>Position the cursor at the given node</p><br>
<h2><a name="Cursor.reset_to"><code>Cursor.reset_to: function(Cursor, Cursor)</code></a></h2>
<p>Re-initialize a tree cursor to the same position as another cursor.</p><br>
<br>
<h2><a name="Language.abi_version"><code>Language.abi_version: function(Language): integer</code></a></h2>
<p>Get the ABI version number for the given parser's language</p><br>
<h2><a name="Language.field_count"><code>Language.field_count: function(Language): integer</code></a></h2>
<p>Get the number of distinct field names in the given parser's language</p><br>
<h2><a name="Language.field_id_for_name"><code>Language.field_id_for_name: function(Language, string): FieldId</code></a></h2>
<p>Get the numeric id for the given field name</p><br>
<h2><a name="Language.metadata"><code>Language.metadata: function(Language): LanguageMetadata</code></a></h2>
<p>Get the metadata for the given language. This information relies on<br>   the language author providing the correct data in the language's<br>   `tree-sitter.json`<br><br>   May return nil</p><br>
<h2><a name="Language.name"><code>Language.name: function(Language): string</code></a></h2>
<p>Get the name of the language. May return nil.</p><br>
<h2><a name="Language.name_for_field_id"><code>Language.name_for_field_id: function(Language, FieldId): string</code></a></h2>
<p>Get the name for a numeric field id</p><br>
<h2><a name="Language.next_state"><code>Language.next_state: function(Language, StateId, Symbol): StateId</code></a></h2>
<p>Get the next parse state</p><br>
<h2><a name="Language.parser"><code>Language.parser: function(Language): Parser</code></a></h2>
<p>Create a parser of the given language</p><br>
<h2><a name="Language.query"><code>Language.query: function(Language, string): Query</code></a></h2>
<p>Create a query out of the given string for this language</p><br>
<h2><a name="Language.state_count"><code>Language.state_count: function(Language): integer</code></a></h2>
<p>Get the number of valid states in the given language</p><br>
<h2><a name="Language.subtypes"><code>Language.subtypes: function(Language, supertype: Symbol): {Symbol}</code></a></h2>
<p>Get a list of all supertype symbols for the given language</p><br>
<h2><a name="Language.supertypes"><code>Language.supertypes: function(Language): {Symbol}</code></a></h2>
<p>Get a list of all supertype symbols for the given language</p><br>
<h2><a name="Language.symbol_count"><code>Language.symbol_count: function(Language): integer</code></a></h2>
<p>Get the number of distinct node types in the given language</p><br>
<h2><a name="Language.symbol_for_name"><code>Language.symbol_for_name: function(Language, string, is_named: boolean): Symbol</code></a></h2>
<p>Get the numerical id for the given node type string</p><br>
<h2><a name="Language.symbol_name"><code>Language.symbol_name: function(Language, Symbol): string</code></a></h2>
<p>Get a node type string for the given symbol id</p><br>
<h2><a name="Language.symbol_type"><code>Language.symbol_type: function(Language, Symbol): SymbolType</code></a></h2>
<p>Check whether the given node type id belongs to named nodes, anonymous nodes,<br>   or hidden nodes</p><br>
<br>
<h2><a name="Node.child"><code>Node.child: function(Node, idx: integer): Node</code></a></h2>
<p>Get the node's idx'th child (0-indexed)</p><br>
<h2><a name="Node.child_by_field_id"><code>Node.child_by_field_id: function(Node, FieldId): Node</code></a></h2>
<p>Get a node's child given a field id</p><br>
<h2><a name="Node.child_by_field_name"><code>Node.child_by_field_name: function(Node, string): Node</code></a></h2>
<p>Get a node's child given a field name</p><br>
<h2><a name="Node.child_count"><code>Node.child_count: function(Node): integer</code></a></h2>
<p>Get the number of children a node has</p><br>
<h2><a name="Node.children"><code>Node.children: function(Node): function(): Node</code></a></h2>
<p>Iterate over a node's children</p><br>
<h2><a name="Node.create_cursor"><code>Node.create_cursor: function(Node): Cursor</code></a></h2>
<p>Create a new cursor at the given node</p><br>
<h2><a name="Node.end_byte"><code>Node.end_byte: function(Node): integer</code></a></h2>
<p>Get the byte of the source string that the given node ends at</p><br>
<h2><a name="Node.end_point"><code>Node.end_point: function(Node): Point</code></a></h2>
<p>Get the row and column of where the given node ends</p><br>
<h2><a name="Node.grammar_symbol"><code>Node.grammar_symbol: function(Node): Symbol</code></a></h2>
<p>Returns the type of a given node as a numeric id as it appears in the grammar ignoring aliases<br><br>   This is what should be used in `Parser:language_next_state` instead of `Node:symbol`</p><br>
<h2><a name="Node.grammar_type"><code>Node.grammar_type: function(Node): string</code></a></h2>
<p>Returns the type of a given node as a string as it appears in the grammar ignoring aliases</p><br>
<h2><a name="Node.is_extra"><code>Node.is_extra: function(Node): boolean</code></a></h2>
<p>Get whether or not the current node is extra</p><br>
<h2><a name="Node.is_missing"><code>Node.is_missing: function(Node): boolean</code></a></h2>
<p>Get whether or not the current node is missing</p><br>
<h2><a name="Node.is_named"><code>Node.is_named: function(Node): boolean</code></a></h2>
<p>Get whether or not the current node is named</p><br>
<h2><a name="Node.name"><code>Node.name: function(Node): string</code></a></h2>
<p>Returns the type of a given node as a string<br>   <pre><br>   print(node) -- => (comment)<br>   print(node:name()) -- => comment<br>   </pre></p><br>
<h2><a name="Node.named_child"><code>Node.named_child: function(Node, idx: integer): Node</code></a></h2>
<p>Get the node's idx'th named child (0-indexed)</p><br>
<h2><a name="Node.named_child_count"><code>Node.named_child_count: function(Node): integer</code></a></h2>
<p>Get the number of named children a node has</p><br>
<h2><a name="Node.named_children"><code>Node.named_children: function(Node): function(): Node</code></a></h2>
<p>Iterate over a node's named children</p><br>
<h2><a name="Node.next_named_sibling"><code>Node.next_named_sibling: function(Node): Node</code></a></h2>
<p>Get a node's next named sibling</p><br>
<h2><a name="Node.next_parse_state"><code>Node.next_parse_state: function(Node): StateId</code></a></h2>
<p>Get the parse state after this node</p><br>
<h2><a name="Node.next_sibling"><code>Node.next_sibling: function(Node): Node</code></a></h2>
<p>Get a node's next sibling</p><br>
<h2><a name="Node.parse_state"><code>Node.parse_state: function(Node): StateId</code></a></h2>
<p>Get this node's parse state</p><br>
<h2><a name="Node.prev_named_sibling"><code>Node.prev_named_sibling: function(Node): Node</code></a></h2>
<p>Get a node's previous named sibling</p><br>
<h2><a name="Node.prev_sibling"><code>Node.prev_sibling: function(Node): Node</code></a></h2>
<p>Get a node's previous sibling</p><br>
<h2><a name="Node.source"><code>Node.source: function(Node): string</code></a></h2>
<p>Get the substring of the source that was parsed to create <code>Node</code></p><br>
<h2><a name="Node.start_byte"><code>Node.start_byte: function(Node): integer</code></a></h2>
<p>Get the byte of the source string that the given node starts at</p><br>
<h2><a name="Node.start_point"><code>Node.start_point: function(Node): Point</code></a></h2>
<p>Get the row and column of where the given node starts</p><br>
<h2><a name="Node.symbol"><code>Node.symbol: function(Node): Symbol</code></a></h2>
<p>Returns the type of a given node as a numeric id</p><br>
<h2><a name="Node.type"><code>Node.type: function(Node): string</code></a></h2>
<p>Get the type of the given node</p><br>
<br>
<h2><a name="Parser.get_ranges"><code>Parser.get_ranges: function(Parser): {Range}</code></a></h2>
<p>Get the ranges of text that the parser will include when parsing</p><br>
<h2><a name="Parser.parse_string"><code>Parser.parse_string: function(Parser, string, ?Encoding, ?Tree): Tree</code></a></h2>
<p>Uses the given parser to parse the string<br><br>   If <code>Tree</code> is provided then it will be used to create a new updated tree<br>   (but it is the responsibility of the programmer to make the correct <code>Tree:edit</code> calls)</p><br>
<h2><a name="Parser.parse_with"><code>Parser.parse_with: function(
   Parser,
   reader: (function(integer, Point): string),
   progress_callback?: (function(has_error: boolean, byte_offset: integer): boolean),
   encoding?: Encoding,
   old_tree?: Tree
   ): Tree</code></a></h2>
<p><code>reader</code> should be a function that takes a byte index<br>   and a <code>Point</code> and returns the text at that point. The<br>   function should return either <code>nil</code> or an empty string<br>   to signal that there is no more text.<br><br>   <code>progress_callback</code> should be a function that takes a boolean<br>   signalling if an error has occurred, and an integer byte offset. This<br>   function will be called intermittently while parsing and may return `true`<br>   to cancel parsing.<br><br>   A <code>Tree</code> can be provided to reuse parts of it for parsing,<br>   provided the <code>Tree:edit</code> has been called previously<br><br>   <code>encoding</code> defaults to <code>"utf-8"</code> when not provided.<br><br>   May return nil if the progress callback cancelled parsing</p><br>
<h2><a name="Parser.reset"><code>Parser.reset: function(Parser)</code></a></h2>
<p>Reset the parser, causing the next parse to start from the beginning</p><br>
<h2><a name="Parser.set_ranges"><code>Parser.set_ranges: function(Parser, {Range}): boolean</code></a></h2>
<p>Sets the ranges that <code>Parser</code> will include when parsing, so you don't have to parse an entire document, but the ranges in the tree will still match the document.<br>   The array of <code>Range</code>s must satisfy the following relationship: for a positive integer <code>i</code> within the length of <code>ranges: {Range}</code>:<br>   <pre><br>   ranges[i].end_byte <= ranges[i + 1].start_byte<br>   </pre><br><br>   returns whether or not setting the range succeeded</p><br>
<br>
<h2><a name="Query._with"><code>Query._with: function(Query, {string:Predicate}): Query</code></a></h2>
<p></p><br>
<h2><a name="Query.capture"><code>Query.capture: function(Query, Node, predicates?: {string:Predicate}, start?: integer | Point, end_?: integer | Point): function(): (Node, string)</code></a></h2>
<p>Iterate over the captures of a given query in <code>Node</code>, <code>name</code> pairs.<br>   <code>start</code> and <code>end</code> are optional.<br>   They must be passed together with the same type, describing either two bytes or two points.<br>   If passed, the query will be executed within the range denoted.<br>   If not passed, the default behaviour is to execute the query through the entire range of the node.<br><br>   <pre><br>   local q = parser:query[[ (comment) @my_match ]]<br>   for capture, name in q:capture(node) do<br>      print(capture, name) -- => (comment), "my_match"<br>   end<br>   </pre></p><br>
<h2><a name="Query.exec"><code>Query.exec: function(Query, Node, predicates?: {string:Predicate}, start?: integer | Point, end_?: integer | Point)</code></a></h2>
<p>Runs a query. That's it. Nothing more, nothing less.<br>   This is intended to be used with the <code>Query.with</code> method and predicates that have side effects,<br>   i.e. for when you would use Query.match or Query.capture, but do nothing in the for loop.<br>   <code>start</code> and <code>end</code> are optional.<br>   They must be passed together with the same type, describing either two bytes or two points.<br>   If passed, the query will be executed within the range denoted.<br>   If not passed, the default behaviour is to execute the query through the entire range of the node.<br><br>   <pre><br>   local parser = ltreesitter.require("teal"):parser()<br><br>   -- grab a node to query against<br>   local root_node = parser:parse_string[[<br>   local x: string = "foo"<br>   local y: string = "bar"<br>   ]]:root()<br><br>   parser<br>      :query[[(<br>         (var_declaration<br>            (var) @var-name<br>            (string) @value)<br>         (#set! @var-name @value)<br>      )]]<br>      :exec(root_node, {["set!"] = function(a, b) _G[a] = b:sub(2, -2) end})<br><br>   print(x) -- => foo<br>   print(y) -- => bar<br><br>   </pre><br><br>   If you'd like to interact with the matches/captures of a query, see the Query.match and Query.capture iterators</p><br>
<h2><a name="Query.match"><code>Query.match: function(Query, Node, predicates?: {string:Predicate}, start?: integer | Point, end_?: integer | Point): function(): Match</code></a></h2>
<p>Iterate over the matches of a given query.<br>   <code>start</code> and <code>end</code> are optional.<br>   They must be passed together with the same type, describing either two bytes or two points.<br>   If passed, the query will be executed within the range denoted.<br>   If not passed, the default behaviour is to execute the query through the entire range of the node.<br><br>   The match object is a record populated with all the information given by treesitter<br>   <pre><br>   interface Match<br>      id: integer<br>      pattern_index: integer<br>      capture_count: integer<br>      captures: {string:Node|{Node}}<br>   end<br>   </pre><br><br>   If a capture can only contain at most one node (as is the case with regular <code>(node) @capture-name</code> patterns and <code>(node)? @capture-name</code> patterns),<br>   it will either be <code>nil</code> or that <code>Node</code>.<br><br>   If a capture can contain multiple nodes (as is the case with <code>(node)* @capture-name</code> and <code>(node)+ @capture-name</code> patterns)<br>   it will either be <code>nil</code> or an array of <code>Node</code><br><br>   Example:<br>   <pre><br>   local q = parser:query[[ (comment) @my_match ]]<br>   for match in q:match(node) do<br>      print(match.captures.my_match)<br>   end<br>   </pre><br><br>   <code>predicates</code> is a map of functions to determine whether a query matches and/or execute side effects<br><br>   Predicates that end in a <code>'?'</code> character will be seen as conditions that must be met for the pattern to be matched.<br>   Predicates that don't will be seen just as functions to be executed given the matches provided.<br><br>   Additionally, you will not have access to the return values of these functions, if you'd like to keep the results of a computation, make your functions have side-effects to write somewhere you can access.<br><br>   By default the following predicates are provided.<br>      <code> (#eq? ...) </code> will match if all arguments provided are equal<br>      <code> (#match? text pattern) </code> will match the provided <code>text</code> matches the given <code>pattern</code>. Matches are determined by Lua's standard <code>string.match</code> function.<br>      <code> (#find? text substring) </code> will match if <code>text</code> contains <code>substring</code>. The substring is found with Lua's standard <code>string.find</code>, but the search always starts from the beginning, and pattern matching is disabled. This is equivalent to <code>string.find(text, substring, 0, true)</code><br><br>   Predicate evaluation order:<br><br>      Since predicates that end with a `?` affect whether a node matches, these are run first, in the order they appear in the query's source. Once all `?` queries are run, all the non-`?` queries are run in the order they appear in the query's source.<br><br>   Example:<br>   The following snippet will match lua functions that have a single LDoc/EmmyLua style comment above them<br>   <pre><br>   local parser = ltreesitter.require("lua"):parser()<br><br>   -- grab a node to query against<br>   local root_node = parser:parse_string[[<br>      ---@Doc this does stuff<br>      local function stuff_doer()<br>         do_stuff()<br>      end<br>   ]]:root()<br><br>   for match in parser<br>      :query[[(<br>         (comment) @the-comment<br>         .<br>         (function_definition<br>            (function_name) @the-function-name)<br>         (#is-doc-comment? @the-comment)<br>      )]]<br>      :match(root_node, {<br>         ["is-doc-comment?"] = function(str)<br>            return str:source():sub(1, 4) == "---@"<br>         end<br>      })<br>   do<br>      print("Function: " .. match.captures["the-function-name"] .. " has documentation")<br>      print("   " .. match.captures["the-comment"])<br>   end<br>   </pre></p><br>
<br>
<h2><a name="Tree.copy"><code>Tree.copy: function(Tree): Tree</code></a></h2>
<p>Creates a copy of the tree. Tree-sitter recommends to create copies if you are going to use multithreading since tree accesses are not thread-safe, but copying them is cheap and quick</p><br>
<h2><a name="Tree.edit"><code>Tree.edit: function(
         Tree,
         start_byte: integer,
         old_end_byte: integer,
         new_end_byte: integer,
         start_point_row: integer,
         start_point_col: integer,
         old_end_point_row: integer,
         old_end_point_col: integer,
         new_end_point_row: integer,
         new_end_point_col: integer
      )</code></a></h2>
<p>Create an edit to the given tree</p><br>
<h2><a name="Tree.edit_s"><code>Tree.edit_s: function(Tree, TreeEdit)</code></a></h2>
<p>Create an edit to the given tree</p><br>
<h2><a name="Tree.get_changed_ranges"><code>Tree.get_changed_ranges: function(old: Tree, new: Tree): {Range}</code></a></h2>
<p>Compare an old syntax tree to a new syntax tree.<br>   This would usually be called right after a set of calls to <code>Tree.edit(_s)</code> and <code>Parser.parse_{string,with}</code></p><br>
<h2><a name="Tree.root"><code>Tree.root: function(Tree): Node</code></a></h2>
<p>Returns the root node of the given parse tree</p><br>
</body></html>
