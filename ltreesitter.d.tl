-- Autogenerated type definitions

local record ltreesitter
   -- Exports

   record Cursor is userdata
      copy: function(Cursor): Cursor
      current_depth: function(Cursor): integer
      current_descendant_index: function(Cursor): integer
      current_field_id: function(Cursor): FieldId
      current_field_name: function(Cursor): string
      current_node: function(Cursor): Node
      goto_descendant: function(Cursor, integer)
      goto_first_child: function(Cursor): boolean
      goto_first_child_for_byte: function(Cursor, integer): integer
      goto_first_child_for_point: function(Cursor, Point): integer
      goto_next_sibling: function(Cursor): boolean
      goto_parent: function(Cursor): boolean
      reset: function(Cursor, Node)
      reset_to: function(Cursor, Cursor)
   end
   record Language is userdata
      abi_version: function(Language): integer
      field_count: function(Language): integer
      field_id_for_name: function(Language, string): FieldId
      metadata: function(Language): LanguageMetadata
      name: function(Language): string
      name_for_field_id: function(Language, FieldId): string
      next_state: function(Language, StateId, Symbol): StateId
      parser: function(Language): Parser
      query: function(Language, string): Query
      state_count: function(Language): integer
      subtypes: function(Language, supertype: Symbol): {Symbol}
      supertypes: function(Language): {Symbol}
      symbol_count: function(Language): integer
      symbol_for_name: function(Language, string, is_named: boolean): Symbol
      symbol_name: function(Language, Symbol): string
      symbol_type: function(Language, Symbol): SymbolType
   end
   record Node is userdata
      child: function(Node, idx: integer): Node
      child_by_field_id: function(Node, FieldId): Node
      child_by_field_name: function(Node, string): Node
      child_count: function(Node): integer
      children: function(Node): function(): Node
      create_cursor: function(Node): Cursor
      end_byte_offset: function(Node): integer
      end_index: function(Node): integer
      end_point: function(Node): Point
      grammar_symbol: function(Node): Symbol
      grammar_type: function(Node): string
      is_extra: function(Node): boolean
      is_missing: function(Node): boolean
      is_named: function(Node): boolean
      name: function(Node): string
      named_child: function(Node, idx: integer): Node
      named_child_count: function(Node): integer
      named_children: function(Node): function(): Node
      next_named_sibling: function(Node): Node
      next_parse_state: function(Node): StateId
      next_sibling: function(Node): Node
      parse_state: function(Node): StateId
      prev_named_sibling: function(Node): Node
      prev_sibling: function(Node): Node
      source: function(Node): string
      start_byte_offset: function(Node): integer
      start_index: function(Node): integer
      start_point: function(Node): Point
      symbol: function(Node): Symbol
      type: function(Node): string
   end
   record Parser is userdata
      get_ranges: function(Parser): {Range}
      parse_string: function(Parser, string, ?Encoding, ?Tree): Tree
      parse_with: function(
   Parser,
   reader: (function(integer, Point): string),
   progress_callback?: (function(has_error: boolean, byte_offset: integer): boolean),
   encoding?: Encoding,
   old_tree?: Tree
   ): Tree
      reset: function(Parser)
      set_ranges: function(Parser, {Range}): boolean
   end
   record Query is userdata
      _with: function(Query, {string:Predicate}): Query
      capture: function(Query, Node, predicates?: {string:Predicate}, start?: integer | Point, end_?: integer | Point): function(): (Node, string)
      exec: function(Query, Node, predicates?: {string:Predicate}, start?: integer | Point, end_?: integer | Point)
      match: function(Query, Node, predicates?: {string:Predicate}, start?: integer | Point, end_?: integer | Point): function(): Match
   end
   TREE_SITTER_LANGUAGE_VERSION: integer
   TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION: integer
   record Tree is userdata
      copy: function(Tree): Tree
      edit: function(
         Tree,
         start_byte: integer,
         old_end_byte: integer,
         new_end_byte: integer,
         start_point_row: integer,
         start_point_col: integer,
         old_end_point_row: integer,
         old_end_point_col: integer,
         new_end_point_row: integer,
         new_end_point_col: integer
      )
      edit_s: function(Tree, TreeEdit)
      get_changed_ranges: function(old: Tree, new: Tree): {Range}
      root: function(Tree): Node
   end
   load: function(file_name: string, language_name: string): Language, string
   require: function(library_file_name: string, language_name?: string): Language, string
   tree_sitter_version: string
   version: string

   -- Inlines

   enum Encoding
      "utf-8"
      "utf-16le"
      "utf-16be"
   end

   enum SymbolType
      "regular"
      "anonymous"
      "supertype"
      "auxiliary"
   end

   interface Range
      start_byte: integer
      end_byte: integer

      start_point: Point
      end_point: Point
   end

   interface TreeEdit
      start_byte: integer
      old_end_byte: integer
      new_end_byte: integer

      start_point: Point
      old_end_point: Point
      new_end_point: Point
   end

   interface Match
      id: integer
      pattern_index: integer
      capture_count: integer
      captures: {string:Node|{Node}}
   end

   type Predicate = function(...: string | Node | {Node}): any...

   interface Point
      row: integer
      column: integer
   end

   type StateId = integer
   type Symbol = integer
   type FieldId = integer

   interface LanguageMetadata
      major_version: integer
      minor_version: integer
      patch_version: integer
   end
end

return ltreesitter
